#include "rv32i_executer_gen.hpp"
#include "../../include/hart.hpp"  // Include Hart for API

// NOTE: this file is autogenerated do not edit it manually
// Generator: rv32i_executer_gen.rb

// Individual execution methods
void RV32IExecuter::execute_add(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp0_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp0_val = rs1_val + rs2_val;
    rd_val = _tmp0_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sub(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp1_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp1_val = rs1_val - rs2_val;
    rd_val = _tmp1_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sll(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp2_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp2_val = rs1_val << rs2_val;
    rd_val = _tmp2_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_slt(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp3_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp3_val = (static_cast<int32_t>(rs1_val) < static_cast<int32_t>(rs2_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sltu(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp5_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp5_val = (rs1_val < rs2_val) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_xor(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp7_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp7_val = rs1_val ^ rs2_val;
    rd_val = _tmp7_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_srl(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp8_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp8_val = rs1_val >> rs2_val;
    rd_val = _tmp8_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sra(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp9_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp9_val = static_cast<uint32_t>(static_cast<int32_t>(rs1_val) >> rs2_val);
    rd_val = _tmp9_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_or(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp10_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp10_val = rs1_val | rs2_val;
    rd_val = _tmp10_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_and(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp11_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp11_val = rs1_val & rs2_val;
    rd_val = _tmp11_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_addi(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp12_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp12_val = rs1_val + imm_val;
    rd_val = _tmp12_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_slti(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp13_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp13_val = (static_cast<int32_t>(rs1_val) < static_cast<int32_t>(imm_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sltiu(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp15_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp15_val = (rs1_val < imm_val) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_xori(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp17_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp17_val = rs1_val ^ imm_val;
    rd_val = _tmp17_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_ori(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp18_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp18_val = rs1_val | imm_val;
    rd_val = _tmp18_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_andi(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp19_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp19_val = rs1_val & imm_val;
    rd_val = _tmp19_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_slli(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp20_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp20_val = rs1_val << imm_val;
    rd_val = _tmp20_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_srli(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp21_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp21_val = rs1_val >> imm_val;
    rd_val = _tmp21_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_srai(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp22_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp22_val = static_cast<uint32_t>(static_cast<int32_t>(rs1_val) >> imm_val);
    rd_val = _tmp22_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_lb(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp23_val;
    uint32_t _tmp24_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp23_val = rs1_val + imm_val;
    _tmp24_val = hart->memory_read(_tmp23_val, 1, true);
    rd_val = _tmp24_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_lh(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp25_val;
    uint32_t _tmp26_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp25_val = rs1_val + imm_val;
    _tmp26_val = hart->memory_read(_tmp25_val, 2, true);
    rd_val = _tmp26_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_lw(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp27_val;
    uint32_t _tmp28_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp27_val = rs1_val + imm_val;
    _tmp28_val = hart->memory_read(_tmp27_val, 4, true);
    rd_val = _tmp28_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_lbu(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp29_val;
    uint32_t _tmp30_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp29_val = rs1_val + imm_val;
    _tmp30_val = hart->memory_read(_tmp29_val, 1, false);
    rd_val = _tmp30_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_lhu(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp31_val;
    uint32_t _tmp32_val;
    rs1_val = hart->get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp31_val = rs1_val + imm_val;
    _tmp32_val = hart->memory_read(_tmp31_val, 2, false);
    rd_val = _tmp32_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_jalr(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t pc_val;
    uint32_t _tmp34_val;
    uint32_t imm_val;
    uint32_t _tmp35_val;
    rs1_val = hart->get_reg(instr.rs1);
    pc_val = hart->get_pc();
    uint32_t _val = 4U;
    _tmp34_val = pc_val + _val;
    rd_val = _tmp34_val;
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp35_val = rs1_val + imm_val;
    hart->set_next_pc(_tmp35_val);
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sb(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t imm_val;
    uint32_t _tmp36_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp36_val = rs1_val + imm_val;
    hart->memory_write(_tmp36_val, rs2_val, 1); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sh(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t imm_val;
    uint32_t _tmp37_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp37_val = rs1_val + imm_val;
    hart->memory_write(_tmp37_val, rs2_val, 2); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_sw(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t imm_val;
    uint32_t _tmp38_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp38_val = rs1_val + imm_val;
    hart->memory_write(_tmp38_val, rs2_val, 4); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_beq(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp39_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp39_val = (rs1_val == rs2_val) ? 1U : 0U;
    if (_tmp39_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp40_val;
        pc_val = hart->get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp40_val = pc_val + imm_val;
        hart->set_next_pc(_tmp40_val);
    } 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_bne(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp41_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp41_val = (rs1_val != rs2_val) ? 1U : 0U;
    if (_tmp41_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp42_val;
        pc_val = hart->get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp42_val = pc_val + imm_val;
        hart->set_next_pc(_tmp42_val);
    } 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_blt(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp43_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp43_val = (static_cast<int32_t>(rs1_val) < static_cast<int32_t>(rs2_val)) ? 1U : 0U;
    if (_tmp43_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp44_val;
        pc_val = hart->get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp44_val = pc_val + imm_val;
        hart->set_next_pc(_tmp44_val);
    } 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_bge(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp45_val;
    uint32_t _tmp47_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp45_val = (static_cast<int32_t>(rs2_val) < static_cast<int32_t>(rs1_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    _tmp47_val = (_tmp45_val != _val) ? 1U : 0U;
    if (_tmp47_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp48_val;
        pc_val = hart->get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp48_val = pc_val + imm_val;
        hart->set_next_pc(_tmp48_val);
    } 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_bltu(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp49_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp49_val = (rs1_val < rs2_val) ? 1U : 0U;
    if (_tmp49_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp50_val;
        pc_val = hart->get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp50_val = pc_val + imm_val;
        hart->set_next_pc(_tmp50_val);
    } 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_bgeu(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp51_val;
    uint32_t _tmp53_val;
    rs1_val = hart->get_reg(instr.rs1);
    rs2_val = hart->get_reg(instr.rs2);
    _tmp51_val = (rs1_val < rs2_val) ? 1U : 0U;
    uint32_t _val = 1U;
    _tmp53_val = (_tmp51_val != _val) ? 1U : 0U;
    if (_tmp53_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp54_val;
        pc_val = hart->get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp54_val = pc_val + imm_val;
        hart->set_next_pc(_tmp54_val);
    } 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_lui(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t imm_val;
    uint32_t _tmp56_val;
    imm_val = static_cast<uint32_t>(instr.imm);
    uint32_t _val = 12U;
    _tmp56_val = imm_val << _val;
    rd_val = _tmp56_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_auipc(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t pc_val;
    uint32_t imm_val;
    uint32_t _tmp58_val;
    uint32_t _tmp59_val;
    pc_val = hart->get_pc();
    imm_val = static_cast<uint32_t>(instr.imm);
    uint32_t _val = 12U;
    _tmp58_val = imm_val << _val;
    _tmp59_val = pc_val + _tmp58_val;
    rd_val = _tmp59_val;
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_jal(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t pc_val;
    uint32_t _tmp61_val;
    uint32_t imm_val;
    uint32_t _tmp62_val;
    pc_val = hart->get_pc();
    uint32_t _val = 4U;
    _tmp61_val = pc_val + _val;
    rd_val = _tmp61_val;
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp62_val = pc_val + imm_val;
    hart->set_next_pc(_tmp62_val);
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


void RV32IExecuter::execute_ecall(const DecodedInstruction& instr, Hart* hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    rs1_val = hart->get_reg(instr.rs1);
    hart->do_ecall();
    hart->set_reg(instr.rd, rd_val); 

    // No explicit return; assume execution completes
}


// Main execute function
void RV32IExecuter::execute(const DecodedInstruction& instr, Hart* hart) {
    std::string name = instr.name;
    if (name == "add") { execute_add(instr, hart); return; }
    if (name == "sub") { execute_sub(instr, hart); return; }
    if (name == "sll") { execute_sll(instr, hart); return; }
    if (name == "slt") { execute_slt(instr, hart); return; }
    if (name == "sltu") { execute_sltu(instr, hart); return; }
    if (name == "xor") { execute_xor(instr, hart); return; }
    if (name == "srl") { execute_srl(instr, hart); return; }
    if (name == "sra") { execute_sra(instr, hart); return; }
    if (name == "or") { execute_or(instr, hart); return; }
    if (name == "and") { execute_and(instr, hart); return; }
    if (name == "addi") { execute_addi(instr, hart); return; }
    if (name == "slti") { execute_slti(instr, hart); return; }
    if (name == "sltiu") { execute_sltiu(instr, hart); return; }
    if (name == "xori") { execute_xori(instr, hart); return; }
    if (name == "ori") { execute_ori(instr, hart); return; }
    if (name == "andi") { execute_andi(instr, hart); return; }
    if (name == "slli") { execute_slli(instr, hart); return; }
    if (name == "srli") { execute_srli(instr, hart); return; }
    if (name == "srai") { execute_srai(instr, hart); return; }
    if (name == "lb") { execute_lb(instr, hart); return; }
    if (name == "lh") { execute_lh(instr, hart); return; }
    if (name == "lw") { execute_lw(instr, hart); return; }
    if (name == "lbu") { execute_lbu(instr, hart); return; }
    if (name == "lhu") { execute_lhu(instr, hart); return; }
    if (name == "jalr") { execute_jalr(instr, hart); return; }
    if (name == "sb") { execute_sb(instr, hart); return; }
    if (name == "sh") { execute_sh(instr, hart); return; }
    if (name == "sw") { execute_sw(instr, hart); return; }
    if (name == "beq") { execute_beq(instr, hart); return; }
    if (name == "bne") { execute_bne(instr, hart); return; }
    if (name == "blt") { execute_blt(instr, hart); return; }
    if (name == "bge") { execute_bge(instr, hart); return; }
    if (name == "bltu") { execute_bltu(instr, hart); return; }
    if (name == "bgeu") { execute_bgeu(instr, hart); return; }
    if (name == "lui") { execute_lui(instr, hart); return; }
    if (name == "auipc") { execute_auipc(instr, hart); return; }
    if (name == "jal") { execute_jal(instr, hart); return; }
    if (name == "ecall") { execute_ecall(instr, hart); return; }
    // If unknown, handle trap or ignore
    hart->handle_unknown_instruction(instr);
}
