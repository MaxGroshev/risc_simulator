#include "rv32i_executer_gen.hpp"
#include "../../include/hart.hpp"
#include "../instruction_opcodes_gen.hpp"

// NOTE: autogenerated, do not edit manually
// Generator: rv32i_executer_gen.rb
void RV32IExecuter::execute_add(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp0_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp0_val = rs1_val + rs2_val;
    rd_val = _tmp0_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_sub(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp1_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp1_val = rs1_val - rs2_val;
    rd_val = _tmp1_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_sll(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp2_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp2_val = rs1_val << rs2_val;
    rd_val = _tmp2_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_slt(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp3_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp3_val = (static_cast<int32_t>(rs1_val) < static_cast<int32_t>(rs2_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_sltu(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp5_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp5_val = ((rs1_val) < (rs2_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_xor(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp7_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp7_val = rs1_val ^ rs2_val;
    rd_val = _tmp7_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_srl(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp8_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp8_val = rs1_val >> rs2_val;
    rd_val = _tmp8_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_sra(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp9_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp9_val = static_cast<uint32_t>(static_cast<int32_t>(rs1_val) >> rs2_val);
    rd_val = _tmp9_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_or(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp10_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp10_val = rs1_val | rs2_val;
    rd_val = _tmp10_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_and(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp11_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp11_val = rs1_val & rs2_val;
    rd_val = _tmp11_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_addi(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp12_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp12_val = rs1_val + imm_val;
    rd_val = _tmp12_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_slti(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp13_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp13_val = (static_cast<int32_t>(rs1_val) < static_cast<int32_t>(imm_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_sltiu(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp15_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp15_val = ((rs1_val) < (imm_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    rd_val = _val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_xori(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp17_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp17_val = rs1_val ^ imm_val;
    rd_val = _tmp17_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_ori(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp18_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp18_val = rs1_val | imm_val;
    rd_val = _tmp18_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_andi(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp19_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp19_val = rs1_val & imm_val;
    rd_val = _tmp19_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_slli(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp20_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp20_val = rs1_val << imm_val;
    rd_val = _tmp20_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_srli(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp21_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp21_val = rs1_val >> imm_val;
    rd_val = _tmp21_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_srai(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp22_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp22_val = static_cast<uint32_t>(static_cast<int32_t>(rs1_val) >> imm_val);
    rd_val = _tmp22_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_lb(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp23_val;
    uint32_t _tmp24_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp23_val = rs1_val + imm_val;
    _tmp24_val = hart.memory_read(_tmp23_val, 1, true);
    rd_val = _tmp24_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_lh(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp25_val;
    uint32_t _tmp26_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp25_val = rs1_val + imm_val;
    _tmp26_val = hart.memory_read(_tmp25_val, 2, true);
    rd_val = _tmp26_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_lw(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp27_val;
    uint32_t _tmp28_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp27_val = rs1_val + imm_val;
    _tmp28_val = hart.memory_read(_tmp27_val, 4, true);
    rd_val = _tmp28_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_lbu(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp29_val;
    uint32_t _tmp30_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp29_val = rs1_val + imm_val;
    _tmp30_val = hart.memory_read(_tmp29_val, 1, false);
    rd_val = _tmp30_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_lhu(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t imm_val;
    uint32_t _tmp31_val;
    uint32_t _tmp32_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp31_val = rs1_val + imm_val;
    _tmp32_val = hart.memory_read(_tmp31_val, 2, false);
    rd_val = _tmp32_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_jalr(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    uint32_t pc_val;
    uint32_t _tmp34_val;
    uint32_t imm_val;
    uint32_t _tmp35_val;
    rs1_val = hart.get_reg(instr.rs1);
    pc_val = hart.get_pc();
    uint32_t _val = 4U;
    _tmp34_val = pc_val + _val;
    rd_val = _tmp34_val;
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp35_val = rs1_val + imm_val;
    hart.set_next_pc(_tmp35_val);
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_sb(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t imm_val;
    uint32_t _tmp36_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp36_val = rs1_val + imm_val;
    hart.memory_write(_tmp36_val, rs2_val, 1); 
}


void RV32IExecuter::execute_sh(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t imm_val;
    uint32_t _tmp37_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp37_val = rs1_val + imm_val;
    hart.memory_write(_tmp37_val, rs2_val, 2); 
}


void RV32IExecuter::execute_sw(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t imm_val;
    uint32_t _tmp38_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp38_val = rs1_val + imm_val;
    hart.memory_write(_tmp38_val, rs2_val, 4); 
}


void RV32IExecuter::execute_beq(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp39_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp39_val = ((rs1_val) == (rs2_val)) ? 1U : 0U;
    if (_tmp39_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp40_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp40_val = pc_val + imm_val;
        hart.set_next_pc(_tmp40_val);
    } 
}


void RV32IExecuter::execute_bne(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp41_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp41_val = ((rs1_val) != (rs2_val)) ? 1U : 0U;
    if (_tmp41_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp42_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp42_val = pc_val + imm_val;
        hart.set_next_pc(_tmp42_val);
    } 
}


void RV32IExecuter::execute_blt(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp43_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp43_val = (static_cast<int32_t>(rs1_val) < static_cast<int32_t>(rs2_val)) ? 1U : 0U;
    if (_tmp43_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp44_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp44_val = pc_val + imm_val;
        hart.set_next_pc(_tmp44_val);
    } 
}


void RV32IExecuter::execute_bge(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp45_val;
    uint32_t _tmp47_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp45_val = (static_cast<int32_t>(rs2_val) < static_cast<int32_t>(rs1_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    _tmp47_val = ((_tmp45_val) != (_val)) ? 1U : 0U;
    if (_tmp47_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp48_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp48_val = pc_val + imm_val;
        hart.set_next_pc(_tmp48_val);
    } 
}


void RV32IExecuter::execute_bltu(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp49_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp49_val = ((rs1_val) < (rs2_val)) ? 1U : 0U;
    if (_tmp49_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp50_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp50_val = pc_val + imm_val;
        hart.set_next_pc(_tmp50_val);
    } 
}


void RV32IExecuter::execute_bgeu(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rs1_val;
    uint32_t rs2_val;
    uint32_t _tmp51_val;
    uint32_t _tmp53_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp51_val = ((rs1_val) < (rs2_val)) ? 1U : 0U;
    uint32_t _val = 1U;
    _tmp53_val = ((_tmp51_val) != (_val)) ? 1U : 0U;
    if (_tmp53_val) {
        uint32_t pc_val;
        uint32_t imm_val;
        uint32_t _tmp54_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint32_t>(instr.imm);
        _tmp54_val = pc_val + imm_val;
        hart.set_next_pc(_tmp54_val);
    } 
}


void RV32IExecuter::execute_lui(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t imm_val;
    uint32_t _tmp56_val;
    imm_val = static_cast<uint32_t>(instr.imm);
    uint32_t _val = 12U;
    _tmp56_val = imm_val << _val;
    rd_val = _tmp56_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_auipc(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t pc_val;
    uint32_t imm_val;
    uint32_t _tmp58_val;
    uint32_t _tmp59_val;
    pc_val = hart.get_pc();
    imm_val = static_cast<uint32_t>(instr.imm);
    uint32_t _val = 12U;
    _tmp58_val = imm_val << _val;
    _tmp59_val = pc_val + _tmp58_val;
    rd_val = _tmp59_val;
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_jal(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t pc_val;
    uint32_t _tmp61_val;
    uint32_t imm_val;
    uint32_t _tmp62_val;
    pc_val = hart.get_pc();
    uint32_t _val = 4U;
    _tmp61_val = pc_val + _val;
    rd_val = _tmp61_val;
    imm_val = static_cast<uint32_t>(instr.imm);
    _tmp62_val = pc_val + imm_val;
    hart.set_next_pc(_tmp62_val);
    hart.set_reg(instr.rd, rd_val); 
}


void RV32IExecuter::execute_ecall(const DecodedInstruction& instr, Hart& hart) {
    // Generated from IR
        uint32_t rd_val;
    uint32_t rs1_val;
    rs1_val = hart.get_reg(instr.rs1);
    hart.do_ecall();
    hart.set_reg(instr.rd, rd_val); 
}

// Main execute: switch on enum opcode
void RV32IExecuter::execute(const DecodedInstruction& instr, Hart& hart) {
    switch (instr.opcode) {
        case InstructionOpcode::ADD: execute_add(instr, hart); return;
 case InstructionOpcode::SUB: execute_sub(instr, hart); return;
 case InstructionOpcode::SLL: execute_sll(instr, hart); return;
 case InstructionOpcode::SLT: execute_slt(instr, hart); return;
 case InstructionOpcode::SLTU: execute_sltu(instr, hart); return;
 case InstructionOpcode::XOR: execute_xor(instr, hart); return;
 case InstructionOpcode::SRL: execute_srl(instr, hart); return;
 case InstructionOpcode::SRA: execute_sra(instr, hart); return;
 case InstructionOpcode::OR: execute_or(instr, hart); return;
 case InstructionOpcode::AND: execute_and(instr, hart); return;
 case InstructionOpcode::ADDI: execute_addi(instr, hart); return;
 case InstructionOpcode::SLTI: execute_slti(instr, hart); return;
 case InstructionOpcode::SLTIU: execute_sltiu(instr, hart); return;
 case InstructionOpcode::XORI: execute_xori(instr, hart); return;
 case InstructionOpcode::ORI: execute_ori(instr, hart); return;
 case InstructionOpcode::ANDI: execute_andi(instr, hart); return;
 case InstructionOpcode::SLLI: execute_slli(instr, hart); return;
 case InstructionOpcode::SRLI: execute_srli(instr, hart); return;
 case InstructionOpcode::SRAI: execute_srai(instr, hart); return;
 case InstructionOpcode::LB: execute_lb(instr, hart); return;
 case InstructionOpcode::LH: execute_lh(instr, hart); return;
 case InstructionOpcode::LW: execute_lw(instr, hart); return;
 case InstructionOpcode::LBU: execute_lbu(instr, hart); return;
 case InstructionOpcode::LHU: execute_lhu(instr, hart); return;
 case InstructionOpcode::JALR: execute_jalr(instr, hart); return;
 case InstructionOpcode::SB: execute_sb(instr, hart); return;
 case InstructionOpcode::SH: execute_sh(instr, hart); return;
 case InstructionOpcode::SW: execute_sw(instr, hart); return;
 case InstructionOpcode::BEQ: execute_beq(instr, hart); return;
 case InstructionOpcode::BNE: execute_bne(instr, hart); return;
 case InstructionOpcode::BLT: execute_blt(instr, hart); return;
 case InstructionOpcode::BGE: execute_bge(instr, hart); return;
 case InstructionOpcode::BLTU: execute_bltu(instr, hart); return;
 case InstructionOpcode::BGEU: execute_bgeu(instr, hart); return;
 case InstructionOpcode::LUI: execute_lui(instr, hart); return;
 case InstructionOpcode::AUIPC: execute_auipc(instr, hart); return;
 case InstructionOpcode::JAL: execute_jal(instr, hart); return;
 case InstructionOpcode::ECALL: execute_ecall(instr, hart); return;
        default:
            hart.handle_unknown_instruction(instr);
    }
}

