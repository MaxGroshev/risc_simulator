require 'yaml'
require 'pathname'
require 'fileutils'

class DecoderGenerator
  def initialize(parsed_isa, yaml_file, generation_dir)
    parsed_isa = parsed_isa.dup.freeze unless parsed_isa.frozen?
    @data = parsed_isa
    @output_dir = generation_dir
    Dir.mkdir(@output_dir) unless Dir.exist?(@output_dir)
  end

  def generate_decoder
    generate_header
    generate_implementation
  end

  private

  def generate_header # TODO(mgroshev) create config for paths
    File.open(File.join(@output_dir, 'rv32i_decoder_gen.hpp'), 'w') do |f|
      f.puts <<~HEADER
        #pragma once
        #include <cstdint>
        #include "decode_execute_module/common.hpp"

        // NOTE: autogenerated - do not edit
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        namespace riscv_sim {
        namespace decoder {

        DecodedInstruction decode(uint32_t instruction);

        } // namespace decoder
        } // namespace riscv_sim
      HEADER
    end
  end

  def generate_implementation
    File.open(File.join(@output_dir, 'rv32i_decoder_gen.cpp'), 'w') do |f|
      f.puts <<~CPP
        #include "rv32i_decoder_gen.hpp"
        #include "decode_execute_module/common.hpp"
        #include "../instruction_opcodes_gen.hpp"

        // NOTE: autogenerated - do not edit
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        namespace riscv_sim {
        namespace decoder {

        uint8_t get_rd(uint32_t instruction) {
            return (instruction >> 7) & 0x1F;
        }

        uint8_t get_rs1(uint32_t instruction) {
            return (instruction >> 15) & 0x1F;
        }

        uint8_t get_rs2(uint32_t instruction) {
            return (instruction >> 20) & 0x1F;
        }

        uint8_t get_funct3(uint32_t instruction) {
            return (instruction >> 12) & 0x7;
        }

        uint8_t get_funct7(uint32_t instruction) {
            return (instruction >> 25) & 0x7F;
        }

        int32_t get_imm_i(uint32_t instruction) {
            return static_cast<int32_t>(instruction) >> 20;
        }

        int32_t get_imm_s(uint32_t instruction) {
            int32_t imm = ((instruction >> 25) & 0x7F) << 5;
            imm |= ((instruction >> 7) & 0x1F);
            return static_cast<int32_t>(imm << 20) >> 20;
        }

        int32_t get_imm_b(uint32_t instruction) {
            int32_t imm = ((instruction >> 31) & 0x1) << 12;
            imm |= ((instruction >> 25) & 0x3F) << 5;
            imm |= ((instruction >> 8) & 0xF) << 1;
            imm |= ((instruction >> 7) & 0x1) << 11;
            return static_cast<int32_t>(imm << 19) >> 19;
        }

        int32_t get_imm_u(uint32_t instruction) {
            return instruction & 0xFFFFF000;
        }

        int32_t get_imm_j(uint32_t instruction) {
            int32_t imm = ((instruction >> 31) & 0x1) << 20;
            imm |= ((instruction >> 21) & 0x3FF) << 1;
            imm |= ((instruction >> 20) & 0x1) << 11;
            imm |= ((instruction >> 12) & 0xFF) << 12;
            return static_cast<int32_t>(imm << 11) >> 11;
        }

        #{generate_instruction_decoders}

        DecodedInstruction decode(uint32_t instruction) {
            DecodedInstruction result;
            result.opcode = InstructionOpcode::UNKNOWN;

            uint8_t opcode = instruction & 0x7F;
            switch (opcode) {
              #{generate_opcode_dispatch}
                default:
                    result.opcode = InstructionOpcode::UNKNOWN;
            }

            return result;
        }

        } // namespace decoder
        } // namespace riscv_sim
      CPP
    end
  end

  def generate_instruction_decoders
    decoders = []

    @data['instructions'].each do |name, instr, frmt|
      decoder = <<~CPP
        DecodedInstruction decode_#{name}(uint32_t instruction) {
            DecodedInstruction result;
            result.opcode = InstructionOpcode::#{name.upcase};
            result.format = InstructionFormat::#{instr['format'].upcase};
            #{generate_field_extraction(name, instr)}

            return result;
        }
      CPP
      decoders << decoder
    end

    decoders.join("\n")
  end

  def generate_field_extraction(instr_name, instr_data)
    fields = []
    fields << "result.rd = get_rd(instruction);" if instr_data['code'].include?('rd')
    fields << "result.rs1 = get_rs1(instruction);" if instr_data['code'].include?('rs1')
    fields << "result.rs2 = get_rs2(instruction);" if instr_data['code'].include?('rs2')
    case instr_data['format']
    when 'R'
      fields << "result.imm = 0;"
    when 'I'
      fields << "result.imm = get_imm_i(instruction);"
    when 'S'
      fields << "result.imm = get_imm_s(instruction);"
    when 'B'
      fields << "result.imm = get_imm_b(instruction);"
    when 'U'
      fields << "result.imm = get_imm_u(instruction);"
    when 'J'
      fields << "result.imm = get_imm_j(instruction);"
    else
      fields << "result.imm = 0;"
    end

    fields.join("\n                ")
  end

    def generate_opcode_dispatch
        opcode_groups = @data['instructions'].group_by { |_, instr| instr['opcode'] }
        dispatch = []
        opcode_groups.each do |opcode, instructions|
            case_stmt = "\n\t\tcase #{opcode}:"
            if instructions.size == 1
                name = instructions.first[0]
                case_stmt += "\n\t\t\tresult = decode_#{name}(instruction);"
            else
                case_stmt += "\n\t\t\tswitch (get_funct3(instruction)) {"
                funct3_groups = instructions.group_by { |_, instr| instr['funct3'] }
                funct3_groups.each do |funct3, instrs|
                    case_stmt += "\n\t\t\t\tcase #{funct3}:"
                    if instrs.size == 1
                        name = instrs.first[0]
                        case_stmt += "\n\t\t\t\t\tresult = decode_#{name}(instruction);"
                    else
                        case_stmt += "\n\t\t\t\t\tswitch (get_funct7(instruction)) {"
                        instrs.each do |name, instr|
                            case_stmt += "\n\t\t\t\t\t\tcase #{instr['funct7']}: result = decode_#{name}(instruction); break;"
                        end
                        case_stmt += "\n\t\t\t\t\t}"
                    end
                case_stmt += "\n\t\t\t\t\tbreak;"
                end
            case_stmt += "\n\t\t\t}"
            end
        case_stmt += "\n\t\t\tbreak;"
        dispatch << case_stmt
        end
        dispatch.join("\n ")
    end
end