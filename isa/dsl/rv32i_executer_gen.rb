require 'yaml'
require 'pathname'
require 'set'
require 'fileutils'

class ExecuterGenerator
  def initialize(instructions, yaml_file, generation_dir, instructions_opcode_dir)
    @instructions = instructions.dup.freeze
    @yaml_file = yaml_file
    @output_dir = generation_dir
    @instructions_opcode_dir = instructions_opcode_dir
    FileUtils.mkdir_p(@output_dir) unless Dir.exist?(@output_dir)
    FileUtils.mkdir_p(@instructions_opcode_dir) unless Dir.exist?(@instructions_opcode_dir)
    generate_enum_headers
  end

  def generate_executer
    generate_header
    generate_implementation
  end

  private

  def generate_enum_headers
    File.open(File.join(@instructions_opcode_dir, 'instruction_opcodes_gen.hpp'), 'w') do |f|
      unique_formats = @instructions.map(&:frmt).uniq    
      f.puts <<~HEADER
        #pragma once
        enum class InstructionOpcode {
            #{@instructions.map { |instr| "#{instr.name.upcase}" }.join(",\n ")},
            UNKNOWN
        };

        enum class InstructionFormat {
            #{unique_formats.map { |frmt| "#{frmt.upcase}" }.join(",\n ")},
            UNKNOWN
        };
      HEADER
    end
  end

  def generate_header
    File.open(File.join(@output_dir, 'rv32i_executer_gen.hpp'), 'w') do |f|
      f.puts <<~HEADER
        #pragma once
        #include <cstdint>
        #include <cstddef>
        #include <memory>
        #include "decode_execute_module/common.hpp"
        #include "../instruction_opcodes_gen.hpp"
        
        #ifdef ENABLE_MODULES
        #include "../../modules_api/callbacks.hpp"
        #endif

        class Hart;

        // NOTE: autogenerated - do not edit
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        namespace riscv_sim {
        namespace executer {

        using ExecFn = void (*)(const DecodedInstruction &instr, Hart& hart);

        ExecFn execute(const DecodedInstruction &instr, Hart& hart);

        #ifdef ENABLE_MODULES
        using PreExecFn = void (*)(const DecodedInstruction &instr, Hart& hart);
        using PostExecFn = void (*)(const DecodedInstruction &instr, Hart& hart, const PostExecInfo& info);

        void ensure_pre_dispatcher_installed(size_t idx);
        void ensure_post_dispatcher_installed(size_t idx);

        void pre_dispatcher(const DecodedInstruction &instr, Hart& hart);
        void post_dispatcher(const DecodedInstruction &instr, Hart& hart, const PostExecInfo& info);
        #endif // ENABLE_MODULES

        #{generate_execution_methods}

        } // namespace executer
        } // namespace riscv_sim
      HEADER
    end
  end

  def generate_execution_methods
    @instructions.map { |instr| "void execute_#{instr.name}(const DecodedInstruction &instr, Hart& hart);" }.join("\n")
  end

  def generate_implementation
    File.open(File.join(@output_dir, 'rv32i_executer_gen.cpp'), 'w') do |f|
      f.puts <<~CPP
        #include "rv32i_executer_gen.hpp"
        #include "hart/hart.hpp"
        #include <vector>
        #include "../instruction_opcodes_gen.hpp"

        // NOTE: autogenerated, do not edit manually
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        namespace riscv_sim {
        namespace executer {

        #ifdef ENABLE_MODULES
        // number of opcodes
        static const size_t OPCODE_COUNT = static_cast<size_t>(InstructionOpcode::UNKNOWN) + 1;

        // per-opcode handler vectors (internal). Use ensure_* functions to install dispatcher when needed.
        static std::vector<PreExecFn> pre_handlers_vec(OPCODE_COUNT, nullptr);
        static std::vector<PostExecFn> post_handlers_vec(OPCODE_COUNT, nullptr);

        size_t opcode_count() { return OPCODE_COUNT; }

        void ensure_pre_dispatcher_installed(size_t idx) {
          if (pre_handlers_vec[idx] == nullptr) {
            pre_handlers_vec[idx] = &pre_dispatcher;
          }
        }

        void ensure_post_dispatcher_installed(size_t idx) {
          if (post_handlers_vec[idx] == nullptr) {
            post_handlers_vec[idx] = &post_dispatcher;
          }
        }

        void pre_dispatcher(const DecodedInstruction &instr, Hart& hart) {
          hart.invoke_pre_callbacks(static_cast<size_t>(instr.opcode), instr);
        }

        void post_dispatcher(const DecodedInstruction &instr, Hart& hart, const PostExecInfo& info) {
          hart.invoke_post_callbacks(static_cast<size_t>(instr.opcode), instr, info);
        }
        #endif // ENABLE_MODULES

        #{generate_instruction_executers}

        ExecFn execute(const DecodedInstruction &instr, Hart& hart) {
          switch (instr.opcode) {
            #{@instructions.map { |instr| "case InstructionOpcode::#{instr.name.upcase}: execute_#{instr.name}(instr, hart); return &execute_#{instr.name};" }.join("\n                ")}
            default:
              hart.handle_exception(ExceptionCause::UnknowInstruction);
              return nullptr;
          }
        }

        } // namespace executer
        } // namespace riscv_sim

      CPP
    end
  end

  def generate_instruction_executers
    executers = []
    @instructions.each do |instr_info|
      executer = <<~CPP
        void execute_#{instr_info.name}(const DecodedInstruction &instr, Hart& hart) {
          #ifdef ENABLE_MODULES
          {
            constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::#{instr_info.name.upcase});
            auto __ph = pre_handlers_vec[__idx];
            if (__ph) __ph(instr, hart);
          }
          #endif

          // Generated from IR
          #{generate_cpp_from_ir(instr_info.code)}
          
          #ifdef ENABLE_MODULES
          {
            constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::#{instr_info.name.upcase});
            auto __ph = post_handlers_vec[__idx];

            if (__ph) {
              PostExecInfo __pei;
              try {
                __pei.read_reg1_val = hart.get_reg(instr.rs1);
                __pei.read_reg1 = static_cast<int32_t>(instr.rs1);
              } catch (...) {
                  __pei.read_reg1 = -1; // invalid
                  __pei.read_reg1_val = 0;
              }

              try {
                __pei.read_reg2_val = hart.get_reg(instr.rs2);
                __pei.read_reg2 = static_cast<int32_t>(instr.rs2);
              } catch (...) {
                  __pei.read_reg2 = -1; // invalid
                  __pei.read_reg2_val = 0;
              }

              try {
                __pei.dest_reg_val = hart.get_reg(instr.rd);
                __pei.dest_reg = static_cast<int32_t>(instr.rd);
              } catch (...) {
                  __pei.read_reg1 = -1; // invalid
                  __pei.read_reg1_val = 0;
              }
              __pei.imm_val = static_cast<uint64_t>(instr.imm);
              __ph(instr, hart, __pei);
            }

          }
          #endif
        }
      CPP
      executers << executer
    end
    executers.join("\n\n")
  end

  def generate_cpp_from_ir(scope, indent = "    ")
    code_lines = []
    declarations = collect_declarations(scope.tree)
    code_lines += declarations.map { |decl| "#{indent}#{decl}" }

    scope.tree.each do |stmt|
      code_lines << translate_stmt(stmt, indent)
    end
    code_lines.compact.join("\n")
  end

  def collect_declarations(tree)
    vars = Set.new
    tree.each do |stmt|
      if stmt.name == :new_var
        var = stmt.oprnds[0]
        vars.add("uint64_t #{var.name}_val;") if var.type == :i32
      end
    end
    vars.to_a
  end

  def translate_stmt(stmt, indent)
    case stmt.name
    when :new_var then nil  # Handled in declarations
    when :getimm then "#{indent}#{get_var_name(stmt.oprnds[0])} = static_cast<uint64_t>(instr.imm);"
    when :getpc then "#{indent}#{get_var_name(stmt.oprnds[0])} = hart.get_pc();"
    when :getreg then "#{indent}#{stmt.oprnds[0]}_val = hart.get_reg(instr.#{stmt.oprnds[0]});"
    when :setreg then "#{indent}hart.set_reg(instr.#{stmt.oprnds[0].name}, #{stmt.oprnds[1]}_val);"
    when :new_const then "#{indent}uint64_t #{stmt.oprnds[0].name}_val = #{stmt.oprnds[0].value}U;"
    when :add, :sub, :bitand, :bitor, :bitxor, :shl, :srl
      op_map = {add: '+', sub: '-', bitand: '&', bitor: '|', bitxor: '^', shl: '<<', srl: '>>'}
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = #{a} #{op_map[stmt.name]} #{b};"
    when :sra
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = static_cast<uint64_t>(static_cast<int64_t>(#{a}) >> #{b});"
    when :eq, :neq, :lt, :gt, :ltu, :gtu
      op_map = {eq: '==', neq: '!=', lt: '<', gt: '>', ltu: '<', gtu: '>'}
      cast = [:lt, :gt].include?(stmt.name) ? 'static_cast<int64_t>' : ''
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (#{cast}(#{a}) #{op_map[stmt.name]} #{cast}(#{b})) ? 1U : 0U;"
    when :load_from_mem
      dest = get_var_name(stmt.oprnds[0])
      addr = get_var_name(stmt.oprnds[1])
      size = stmt.attrs[:size] || :word
      sign = stmt.attrs[:sign] == :signed
      size_bytes = {byte: 1, half: 2, word: 4}[size]
      "#{indent}#{dest} = hart.memory_read(#{addr}, #{size_bytes}, #{sign});"
    when :store_to_mem
      addr = get_var_name(stmt.oprnds[0])
      src = get_var_name(stmt.oprnds[1])
      size = stmt.attrs[:size] || :word
      size_bytes = {byte: 1, half: 2, word: 4}[size]
      "#{indent}hart.memory_write(#{addr}, #{src}, #{size_bytes});"
    when :setpc then "#{indent}hart.set_next_pc(#{get_var_name(stmt.oprnds[0])});"
    when :if_expr
      cond = get_var_name(stmt.oprnds[0])
      body_code = generate_cpp_from_ir(stmt.oprnds[1], indent + "    ")
      "#{indent}if (#{cond}) {\n#{body_code}\n#{indent}}"
    when :let then "#{indent}#{get_var_name(stmt.oprnds[0])} = #{get_var_name(stmt.oprnds[1])};"
    when :ecall then "#{indent}hart.do_ecall();"
    when :ebreak then "#{indent}hart.set_halt(true);"
    else "#{indent}// Unsupported: #{stmt.name}"
    end
  end

  def get_operands(oprnds)
    [get_var_name(oprnds[0]), get_var_name(oprnds[1]), get_var_name(oprnds[2])]
  end

  def get_var_name(operand)
    if operand.is_a?(SimInfra::Var) || operand.is_a?(SimInfra::Constant)
      "#{operand.name}_val"
    else
      raise "Unknown operand: #{operand.class}"
    end
  end
end
