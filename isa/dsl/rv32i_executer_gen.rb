require 'yaml'
require 'pathname'
require 'set'
require 'fileutils'

class ExecuterGenerator
  def initialize(instructions, yaml_file, generation_dir, instructions_opcode_dir)
    @instructions = instructions.dup.freeze
    @yaml_file = yaml_file
    @output_dir = generation_dir
    @instructions_opcode_dir = instructions_opcode_dir
    FileUtils.mkdir_p(@output_dir) unless Dir.exist?(@output_dir)
    FileUtils.mkdir_p(@instructions_opcode_dir) unless Dir.exist?(@instructions_opcode_dir)
    generate_enum_header
  end

  def generate_executer
    generate_header
    generate_implementation
  end

  private

  def generate_enum_header
    File.open(File.join(@instructions_opcode_dir, 'instruction_opcodes_gen.hpp'), 'w') do |f|
      f.puts <<~HEADER
        #pragma once
        enum class InstructionOpcode {
            #{@instructions.map { |instr| "#{instr.name.upcase}" }.join(",\n ")},
            UNKNOWN
        };
      HEADER
    end
  end

  def generate_header
    File.open(File.join(@output_dir, 'rv32i_executer_gen.hpp'), 'w') do |f|
      f.puts <<~HEADER
        #pragma once
        #include <cstdint>
        #include "decode_execute_module/common.hpp"
        #include "../instruction_opcodes_gen.hpp"

        class Hart;

        // NOTE: autogenerated - do not edit
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        namespace riscv_sim {
        namespace executer {

        using ExecFn = void (*)(const DecodedInstruction instr, Hart& hart);

        ExecFn execute(const DecodedInstruction instr, Hart& hart);

        #{generate_execution_methods}

        } // namespace executer
        } // namespace riscv_sim
      HEADER
    end
  end

  def generate_execution_methods
    @instructions.map { |instr| "void execute_#{instr.name}(const DecodedInstruction instr, Hart& hart);" }.join("\n        ")
  end

  def generate_implementation
    File.open(File.join(@output_dir, 'rv32i_executer_gen.cpp'), 'w') do |f|
      f.puts <<~CPP
        #include "rv32i_executer_gen.hpp"
        #include "hart/hart.hpp"
        #include "../instruction_opcodes_gen.hpp"

        // NOTE: autogenerated, do not edit manually
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        namespace riscv_sim {
        namespace executer {

        #{generate_instruction_executers}

        ExecFn execute(const DecodedInstruction instr, Hart& hart) {
            switch (instr.opcode) {
                #{@instructions.map { |instr| "case InstructionOpcode::#{instr.name.upcase}: execute_#{instr.name}(instr, hart); return &execute_#{instr.name};" }.join("\n                ")}
                default:
                    hart.handle_unknown_instruction(instr);
                    return nullptr;
            }
        }

        } // namespace executer
        } // namespace riscv_sim

      CPP
    end
  end

  def generate_instruction_executers
    executers = []
    @instructions.each do |instr_info|
      executer = <<~CPP
        void execute_#{instr_info.name}(const DecodedInstruction instr, Hart& hart) {
            // Generated from IR
            #{generate_cpp_from_ir(instr_info.code)}
        }
      CPP
      executers << executer
    end
    executers.join("\n\n")
  end

  def generate_cpp_from_ir(scope, indent = "    ")
    code_lines = []
    declarations = collect_declarations(scope.tree)
    code_lines += declarations.map { |decl| "#{indent}#{decl}" }

    scope.tree.each do |stmt|
      code_lines << translate_stmt(stmt, indent)
    end
    code_lines.compact.join("\n")
  end

  def collect_declarations(tree)
    vars = Set.new
    tree.each do |stmt|
      if stmt.name == :new_var
        var = stmt.oprnds[0]
        vars.add("uint32_t #{var.name}_val;") if var.type == :i32
      end
    end
    vars.to_a
  end

  def translate_stmt(stmt, indent)
    case stmt.name
    when :new_var then nil  # Handled in declarations
    when :getimm then "#{indent}#{get_var_name(stmt.oprnds[0])} = static_cast<uint32_t>(instr.imm);"
    when :getpc then "#{indent}#{get_var_name(stmt.oprnds[0])} = hart.get_pc();"
    when :getreg then "#{indent}#{stmt.oprnds[0]}_val = hart.get_reg(instr.#{stmt.oprnds[0]});"
    when :setreg then "#{indent}hart.set_reg(instr.#{stmt.oprnds[0].name}, #{stmt.oprnds[1]}_val);"
    when :new_const then "#{indent}uint32_t #{stmt.oprnds[0].name}_val = #{stmt.oprnds[0].value}U;"
    when :add, :sub, :bitand, :bitor, :bitxor, :shl, :srl
      op_map = {add: '+', sub: '-', bitand: '&', bitor: '|', bitxor: '^', shl: '<<', srl: '>>'}
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = #{a} #{op_map[stmt.name]} #{b};"
    when :sra
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = static_cast<uint32_t>(static_cast<int32_t>(#{a}) >> #{b});"
    when :eq, :neq, :lt, :gt, :ltu, :gtu
      op_map = {eq: '==', neq: '!=', lt: '<', gt: '>', ltu: '<', gtu: '>'}
      cast = [:lt, :gt].include?(stmt.name) ? 'static_cast<int32_t>' : ''
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (#{cast}(#{a}) #{op_map[stmt.name]} #{cast}(#{b})) ? 1U : 0U;"
    when :load_from_mem
      dest = get_var_name(stmt.oprnds[0])
      addr = get_var_name(stmt.oprnds[1])
      size = stmt.attrs[:size] || :word
      sign = stmt.attrs[:sign] == :signed
      size_bytes = {byte: 1, half: 2, word: 4}[size]
      "#{indent}#{dest} = hart.memory_read(#{addr}, #{size_bytes}, #{sign});"
    when :store_to_mem
      addr = get_var_name(stmt.oprnds[0])
      src = get_var_name(stmt.oprnds[1])
      size = stmt.attrs[:size] || :word
      size_bytes = {byte: 1, half: 2, word: 4}[size]
      "#{indent}hart.memory_write(#{addr}, #{src}, #{size_bytes});"
    when :setpc then "#{indent}hart.set_next_pc(#{get_var_name(stmt.oprnds[0])});"
    when :if_expr
      cond = get_var_name(stmt.oprnds[0])
      body_code = generate_cpp_from_ir(stmt.oprnds[1], indent + "    ")
      "#{indent}if (#{cond}) {\n#{body_code}\n#{indent}}"
    when :let then "#{indent}#{get_var_name(stmt.oprnds[0])} = #{get_var_name(stmt.oprnds[1])};"
    when :ecall then "#{indent}hart.do_ecall();"
    when :ebreak then "#{indent}hart.set_halt(true);"
    else "#{indent}// Unsupported: #{stmt.name}"
    end
  end

  def get_operands(oprnds)
    [get_var_name(oprnds[0]), get_var_name(oprnds[1]), get_var_name(oprnds[2])]
  end

  def get_var_name(operand)
    if operand.is_a?(SimInfra::Var) || operand.is_a?(SimInfra::Constant)
      "#{operand.name}_val"
    else
      raise "Unknown operand: #{operand.class}"
    end
  end
end
