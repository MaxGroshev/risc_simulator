require 'yaml'
require 'pathname'
require 'set'

class ExecuterGenerator
  def initialize(instructions, yaml_file, generation_dir)
    @instructions = instructions.dup.freeze unless instructions.frozen?
    @yaml_file = yaml_file
    @output_dir = generation_dir
    Dir.mkdir(@output_dir) unless Dir.exist?(@output_dir)
  end

  def generate_executer
    generate_header
    generate_implementation
  end

  private

  def generate_header
    File.open(File.join(@output_dir, 'rv32i_executer_gen.hpp'), 'w') do |f|
      f.puts <<~HEADER
        #pragma once
        #include <cstdint>
        #include "../../include/common.hpp"   // Include DecodedInstruction

        class Hart;  // Forward declaration

        // NOTE: this file is autogenerated do not edit it manually
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}
        // RV32I Executer class
        class RV32IExecuter {
        public:
            static void execute(const DecodedInstruction& instr, Hart* hart);
            
        private:
            #{generate_execution_methods}
        };
      HEADER
    end
  end

  def generate_execution_methods
    methods = []
    @instructions.each do |instr|
      methods << "static void execute_#{instr.name}(const DecodedInstruction& instr, Hart* hart);" unless instr.name == 'ret'
    end
    methods.join("\n    ")
  end

  def generate_implementation
    File.open(File.join(@output_dir, 'rv32i_executer_gen.cpp'), 'w') do |f|
      f.puts <<~CPP
        #include "rv32i_executer_gen.hpp"
        #include "../../include/hart.hpp"  // Include Hart for API

        // NOTE: this file is autogenerated do not edit it manually
        // Generator: #{Pathname.new(__FILE__).relative_path_from(Pathname.new(Dir.pwd))}

        // Individual execution methods
        #{generate_instruction_executers}

        // Main execute function
        void RV32IExecuter::execute(const DecodedInstruction& instr, Hart* hart) {
            std::string name = instr.name;
            #{generate_name_dispatch}
            // If unknown, handle trap or ignore
            hart->handle_unknown_instruction(instr);
        }
      CPP
    end
  end

  def generate_instruction_executers
    executers = []
    @instructions.each do |instr_info|
      executer = <<~CPP
        void RV32IExecuter::execute_#{instr_info.name}(const DecodedInstruction& instr, Hart* hart) {
            // Generated from IR
            #{generate_cpp_from_ir(instr_info.code)} 

            // No explicit return; assume execution completes
        }
      CPP
      executers << executer
    end
    executers.join("\n\n")
  end

  def generate_cpp_from_ir(scope, indent = "    ")
    code_lines = []
    declarations = collect_declarations(scope.tree)
    code_lines += declarations.map { |decl| "#{indent}#{decl}" }

    scope.tree.each do |stmt|
      code_lines << translate_stmt(stmt, indent)
    end
    code_lines.compact.join("\n")
  end

  def collect_declarations(tree)
    vars = Set.new
    tree.each do |stmt|
      if stmt.name == :new_var
        var = stmt.oprnds[0]
        vars.add("uint32_t #{var.name}_val;") if var.type == :i32
      end
    end
    vars.to_a
  end

  def translate_stmt(stmt, indent)
    case stmt.name
    when :new_var
      nil  # Declarations collected at top
    when :getimm
      imm_var = stmt.oprnds[0]  # Var :imm
      "#{indent}#{get_var_name(imm_var)} = static_cast<uint32_t>(instr.imm);"
    when :getpc
      pc_var = stmt.oprnds[0]  # Var :pc
      "#{indent}#{get_var_name(pc_var)} = hart->get_pc();"
    when :getreg
      reg_sym = stmt.oprnds[0]  # :rs1 or :rs2 etc.
      "#{indent}#{reg_sym}_val = hart->get_reg(instr.#{reg_sym});"
    when :setreg
      field = stmt.oprnds[0]  # Field :rd
      reg_sym = stmt.oprnds[1]  # :rd
      "#{indent}hart->set_reg(instr.#{field.name}, #{reg_sym}_val);"
    when :new_const
      const = stmt.oprnds[0]
      "#{indent}uint32_t #{const.name}_val = #{const.value}U;"
    when :add, :sub, :bitand, :bitor, :bitxor, :shl, :srl
      op_map = {add: '+', sub: '-', bitand: '&', bitor: '|', bitxor: '^', shl: '<<', srl: '>>'}
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = #{a} #{op_map[stmt.name]} #{b};"
    when :sra
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = static_cast<uint32_t>(static_cast<int32_t>(#{a}) >> #{b});"
    when :eq
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (#{a} == #{b}) ? 1U : 0U;"
    when :neq
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (#{a} != #{b}) ? 1U : 0U;"
    when :lt
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (static_cast<int32_t>(#{a}) < static_cast<int32_t>(#{b})) ? 1U : 0U;"
    when :gt
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (static_cast<int32_t>(#{a}) > static_cast<int32_t>(#{b})) ? 1U : 0U;"
    when :ltu
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (#{a} < #{b}) ? 1U : 0U;"
    when :gtu
      dest, a, b = get_operands(stmt.oprnds)
      "#{indent}#{dest} = (#{a} > #{b}) ? 1U : 0U;"
    when :load_from_mem
      dest = get_var_name(stmt.oprnds[0])
      addr = get_var_name(stmt.oprnds[1])
      size = stmt.attrs[:size] || :word
      sign = stmt.attrs[:sign] == :signed
      size_bytes = {byte: 1, half: 2, word: 4}[size]
      "#{indent}#{dest} = hart->memory_read(#{addr}, #{size_bytes}, #{sign});"
    when :store_to_mem
      addr = get_var_name(stmt.oprnds[0])
      src = get_var_name(stmt.oprnds[1])
      size = stmt.attrs[:size] || :word
      size_bytes = {byte: 1, half: 2, word: 4}[size]
      "#{indent}hart->memory_write(#{addr}, #{src}, #{size_bytes});"
    when :setpc
      value = get_var_name(stmt.oprnds[0])
      "#{indent}hart->set_next_pc(#{value});"
    when :if_expr
      cond = get_var_name(stmt.oprnds[0])
      body_scope = stmt.oprnds[1]
      body_code = generate_cpp_from_ir(body_scope, indent + "    ")
      "#{indent}if (#{cond}) {\n#{body_code}\n#{indent}}"
    when :let
      left = get_var_name(stmt.oprnds[0])
      right = get_var_name(stmt.oprnds[1])
      "#{indent}#{left} = #{right};"
    when :ecall
      "#{indent}hart->do_ecall();"
    when :ebreak
      "#{indent}hart->set_halt(true);"
    else
      "#{indent}// Unsupported stmt: #{stmt.name}"
    end
  end

  def get_operands(oprnds)
    dest = get_var_name(oprnds[0])
    a = get_var_name(oprnds[1])
    b = get_var_name(oprnds[2])
    [dest, a, b]
  end

  def get_var_name(operand)
    if operand.is_a?(SimInfra::Var)
      "#{operand.name}_val"
    elsif operand.is_a?(SimInfra::Constant)
      "#{operand.name}_val"
    else
      raise "Unknown operand type: #{operand.class}"
    end
  end

  def generate_name_dispatch
    dispatch = @instructions.map do |instr|
      "if (name == \"#{instr.name}\") { execute_#{instr.name}(instr, hart); return; }"
    end
    dispatch.join("\n    ")
  end
end