#include "rv32i_executer_gen.hpp"
#include "hart/hart.hpp"
#include <vector>
#include "../instruction_opcodes_gen.hpp"

// NOTE: autogenerated, do not edit manually
// Generator: dsl/rv32i_executer_gen.rb

namespace riscv_sim {
namespace executer {

// number of opcodes
static const size_t OPCODE_COUNT = static_cast<size_t>(InstructionOpcode::UNKNOWN) + 1;

// per-opcode handler vectors (internal). Use ensure_* functions to install dispatcher when needed.
static std::vector<ExecFn> pre_handlers_vec(OPCODE_COUNT, nullptr);
static std::vector<ExecFn> post_handlers_vec(OPCODE_COUNT, nullptr);

size_t opcode_count() { return OPCODE_COUNT; }

void ensure_pre_dispatcher_installed(size_t idx) {
  if (pre_handlers_vec[idx] == nullptr) {
    pre_handlers_vec[idx] = &pre_dispatcher;
  }
}

void ensure_post_dispatcher_installed(size_t idx) {
  if (post_handlers_vec[idx] == nullptr) {
    post_handlers_vec[idx] = &post_dispatcher;
  }
}

void pre_dispatcher(const DecodedInstruction instr, Hart& hart) {
  hart.invoke_pre_callbacks_by_index(static_cast<size_t>(instr.opcode), instr);
}

void post_dispatcher(const DecodedInstruction instr, Hart& hart) {
  hart.invoke_post_callbacks_by_index(static_cast<size_t>(instr.opcode), instr);
}

void execute_lb(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LB);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp0_val;
    uint64_t _tmp1_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp0_val = rs1_val + imm_val;
    _tmp1_val = hart.load(_tmp0_val, 1);
    rd_val = _tmp1_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LB);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_lh(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LH);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp2_val;
    uint64_t _tmp3_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp2_val = rs1_val + imm_val;
    _tmp3_val = hart.load(_tmp2_val, 2);
    rd_val = _tmp3_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LH);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_lw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp4_val;
    uint64_t _tmp5_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp4_val = rs1_val + imm_val;
    _tmp5_val = hart.load(_tmp4_val, 4);
    rd_val = _tmp5_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_ld(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LD);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp6_val;
    uint64_t _tmp7_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp6_val = rs1_val + imm_val;
    _tmp7_val = hart.load(_tmp6_val, 8);
    rd_val = _tmp7_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LD);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_lbu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LBU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp8_val;
    uint64_t _tmp9_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp8_val = rs1_val + imm_val;
    _tmp9_val = hart.load(_tmp8_val, 1);
    rd_val = _tmp9_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LBU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_lhu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LHU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp10_val;
    uint64_t _tmp11_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp10_val = rs1_val + imm_val;
    _tmp11_val = hart.load(_tmp10_val, 2);
    rd_val = _tmp11_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LHU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_lwu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LWU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp12_val;
    uint64_t _tmp13_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp12_val = rs1_val + imm_val;
    _tmp13_val = hart.load(_tmp12_val, 4);
    rd_val = _tmp13_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LWU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sb(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SB);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t imm_val;
    uint64_t _tmp14_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp14_val = rs1_val + imm_val;
    hart.store(_tmp14_val, rs2_val, 1);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SB);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sh(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SH);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t imm_val;
    uint64_t _tmp15_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp15_val = rs1_val + imm_val;
    hart.store(_tmp15_val, rs2_val, 2);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SH);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t imm_val;
    uint64_t _tmp16_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp16_val = rs1_val + imm_val;
    hart.store(_tmp16_val, rs2_val, 4);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sd(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SD);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t imm_val;
    uint64_t _tmp17_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp17_val = rs1_val + imm_val;
    hart.store(_tmp17_val, rs2_val, 8);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SD);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_addiw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADDIW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp18_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    int32_t tmp = static_cast<int32_t>(rs1_val & 0xFFFFFFFFULL) + static_cast<int32_t>(imm_val & 0xFFFFFFFFULL);
    _tmp18_val = static_cast<uint64_t>(static_cast<int64_t>(tmp));
    rd_val = _tmp18_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADDIW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_slliw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLLIW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp19_val;
    uint64_t _tmp21_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    uint64_t _val = 31U;
    _tmp21_val = imm_val & _val;
    uint32_t res = static_cast<uint32_t>(rs1_val & 0xFFFFFFFFULL) << _tmp21_val;
    _tmp19_val = static_cast<uint64_t>(res);
    rd_val = _tmp19_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLLIW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_srliw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRLIW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp22_val;
    uint64_t _tmp24_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    uint64_t _val = 31U;
    _tmp24_val = imm_val & _val;
    uint32_t res = static_cast<uint32_t>(rs1_val & 0xFFFFFFFFULL) >> _tmp24_val;
    _tmp22_val = static_cast<uint64_t>(res);
    rd_val = _tmp22_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRLIW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sraiw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRAIW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp25_val;
    uint64_t _tmp27_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    uint64_t _val = 31U;
    _tmp27_val = imm_val & _val;
    int32_t res = static_cast<int32_t>(rs1_val & 0xFFFFFFFFULL) >> _tmp27_val;
    _tmp25_val = static_cast<uint64_t>(static_cast<int64_t>(res));
    rd_val = _tmp25_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRAIW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_addw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADDW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp28_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    int32_t tmp = static_cast<int32_t>(rs1_val & 0xFFFFFFFFULL) + static_cast<int32_t>(rs2_val & 0xFFFFFFFFULL);
    _tmp28_val = static_cast<uint64_t>(static_cast<int64_t>(tmp));
    rd_val = _tmp28_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADDW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_subw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SUBW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp29_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    int32_t tmp = static_cast<int32_t>(rs1_val & 0xFFFFFFFFULL) - static_cast<int32_t>(rs2_val & 0xFFFFFFFFULL);
    _tmp29_val = static_cast<uint64_t>(static_cast<int64_t>(tmp));
    rd_val = _tmp29_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SUBW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sllw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLLW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp30_val;
    uint64_t _tmp32_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    uint64_t _val = 31U;
    _tmp32_val = rs2_val & _val;
    uint32_t res = static_cast<uint32_t>(rs1_val & 0xFFFFFFFFULL) << _tmp32_val;
    _tmp30_val = static_cast<uint64_t>(res);
    rd_val = _tmp30_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLLW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_srlw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRLW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp33_val;
    uint64_t _tmp35_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    uint64_t _val = 31U;
    _tmp35_val = rs2_val & _val;
    uint32_t res = static_cast<uint32_t>(rs1_val & 0xFFFFFFFFULL) >> _tmp35_val;
    _tmp33_val = static_cast<uint64_t>(res);
    rd_val = _tmp33_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRLW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sraw(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRAW);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp36_val;
    uint64_t _tmp38_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    uint64_t _val = 31U;
    _tmp38_val = rs2_val & _val;
    int32_t res = static_cast<int32_t>(rs1_val & 0xFFFFFFFFULL) >> _tmp38_val;
    _tmp36_val = static_cast<uint64_t>(static_cast<int64_t>(res));
    rd_val = _tmp36_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRAW);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_add(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADD);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp39_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp39_val = rs1_val + rs2_val;
    rd_val = _tmp39_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADD);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sub(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SUB);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp40_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp40_val = rs1_val - rs2_val;
    rd_val = _tmp40_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SUB);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sll(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLL);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp41_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp41_val = rs1_val << rs2_val;
    rd_val = _tmp41_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLL);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_slt(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLT);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp42_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp42_val = (static_cast<int64_t>(rs1_val) < static_cast<int64_t>(rs2_val)) ? 1U : 0U;
    rd_val = _tmp42_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLT);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sltu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLTU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp43_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp43_val = ((rs1_val) < (rs2_val)) ? 1U : 0U;
    rd_val = _tmp43_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLTU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_xor(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::XOR);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp44_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp44_val = rs1_val ^ rs2_val;
    rd_val = _tmp44_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::XOR);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_srl(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRL);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp45_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp45_val = rs1_val >> rs2_val;
    rd_val = _tmp45_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRL);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sra(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRA);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp46_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp46_val = static_cast<uint64_t>(static_cast<int64_t>(rs1_val) >> rs2_val);
    rd_val = _tmp46_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRA);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_or(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::OR);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp47_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp47_val = rs1_val | rs2_val;
    rd_val = _tmp47_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::OR);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_and(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::AND);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp48_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp48_val = rs1_val & rs2_val;
    rd_val = _tmp48_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::AND);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_addi(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADDI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp49_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp49_val = rs1_val + imm_val;
    rd_val = _tmp49_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ADDI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_slti(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLTI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp50_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp50_val = (static_cast<int64_t>(rs1_val) < static_cast<int64_t>(imm_val)) ? 1U : 0U;
    rd_val = _tmp50_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLTI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_sltiu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLTIU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp51_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp51_val = ((rs1_val) < (imm_val)) ? 1U : 0U;
    rd_val = _tmp51_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLTIU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_xori(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::XORI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp52_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp52_val = rs1_val ^ imm_val;
    rd_val = _tmp52_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::XORI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_ori(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ORI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp53_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp53_val = rs1_val | imm_val;
    rd_val = _tmp53_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ORI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_andi(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ANDI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp54_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp54_val = rs1_val & imm_val;
    rd_val = _tmp54_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ANDI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_slli(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLLI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp55_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp55_val = rs1_val << imm_val;
    rd_val = _tmp55_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SLLI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_srli(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRLI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp56_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp56_val = rs1_val >> imm_val;
    rd_val = _tmp56_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRLI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_srai(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRAI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t imm_val;
    uint64_t _tmp57_val;
    rs1_val = hart.get_reg(instr.rs1);
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp57_val = static_cast<uint64_t>(static_cast<int64_t>(rs1_val) >> imm_val);
    rd_val = _tmp57_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::SRAI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_jalr(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::JALR);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    uint64_t pc_val;
    uint64_t _tmp59_val;
    uint64_t imm_val;
    uint64_t _tmp60_val;
    rs1_val = hart.get_reg(instr.rs1);
    pc_val = hart.get_pc();
    uint64_t _val = 4U;
    _tmp59_val = pc_val + _val;
    rd_val = _tmp59_val;
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp60_val = rs1_val + imm_val;
    hart.set_next_pc(_tmp60_val);
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::JALR);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_beq(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BEQ);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp61_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp61_val = ((rs1_val) == (rs2_val)) ? 1U : 0U;
    if (_tmp61_val) {
        uint64_t pc_val;
        uint64_t imm_val;
        uint64_t _tmp62_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint64_t>(instr.imm);
        _tmp62_val = pc_val + imm_val;
        hart.set_next_pc(_tmp62_val);
    }
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BEQ);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_bne(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BNE);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp63_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp63_val = ((rs1_val) != (rs2_val)) ? 1U : 0U;
    if (_tmp63_val) {
        uint64_t pc_val;
        uint64_t imm_val;
        uint64_t _tmp64_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint64_t>(instr.imm);
        _tmp64_val = pc_val + imm_val;
        hart.set_next_pc(_tmp64_val);
    }
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BNE);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_blt(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BLT);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp65_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp65_val = (static_cast<int64_t>(rs1_val) < static_cast<int64_t>(rs2_val)) ? 1U : 0U;
    if (_tmp65_val) {
        uint64_t pc_val;
        uint64_t imm_val;
        uint64_t _tmp66_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint64_t>(instr.imm);
        _tmp66_val = pc_val + imm_val;
        hart.set_next_pc(_tmp66_val);
    }
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BLT);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_bge(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BGE);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp67_val;
    uint64_t _tmp69_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp67_val = (static_cast<int64_t>(rs1_val) < static_cast<int64_t>(rs2_val)) ? 1U : 0U;
    uint64_t _val = 1U;
    _tmp69_val = ((_tmp67_val) != (_val)) ? 1U : 0U;
    if (_tmp69_val) {
        uint64_t pc_val;
        uint64_t imm_val;
        uint64_t _tmp70_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint64_t>(instr.imm);
        _tmp70_val = pc_val + imm_val;
        hart.set_next_pc(_tmp70_val);
    }
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BGE);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_bltu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BLTU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp71_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp71_val = ((rs1_val) < (rs2_val)) ? 1U : 0U;
    if (_tmp71_val) {
        uint64_t pc_val;
        uint64_t imm_val;
        uint64_t _tmp72_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint64_t>(instr.imm);
        _tmp72_val = pc_val + imm_val;
        hart.set_next_pc(_tmp72_val);
    }
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BLTU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_bgeu(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BGEU);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rs1_val;
    uint64_t rs2_val;
    uint64_t _tmp73_val;
    uint64_t _tmp75_val;
    rs1_val = hart.get_reg(instr.rs1);
    rs2_val = hart.get_reg(instr.rs2);
    _tmp73_val = ((rs1_val) < (rs2_val)) ? 1U : 0U;
    uint64_t _val = 1U;
    _tmp75_val = ((_tmp73_val) != (_val)) ? 1U : 0U;
    if (_tmp75_val) {
        uint64_t pc_val;
        uint64_t imm_val;
        uint64_t _tmp76_val;
        pc_val = hart.get_pc();
        imm_val = static_cast<uint64_t>(instr.imm);
        _tmp76_val = pc_val + imm_val;
        hart.set_next_pc(_tmp76_val);
    }
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::BGEU);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_lui(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LUI);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t imm_val;
    uint64_t _tmp78_val;
    imm_val = static_cast<uint64_t>(instr.imm);
    uint64_t _val = 12U;
    _tmp78_val = imm_val << _val;
    rd_val = _tmp78_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::LUI);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_auipc(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::AUIPC);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t pc_val;
    uint64_t imm_val;
    uint64_t _tmp80_val;
    uint64_t _tmp81_val;
    pc_val = hart.get_pc();
    imm_val = static_cast<uint64_t>(instr.imm);
    uint64_t _val = 12U;
    _tmp80_val = imm_val << _val;
    _tmp81_val = pc_val + _tmp80_val;
    rd_val = _tmp81_val;
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::AUIPC);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_jal(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::JAL);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t pc_val;
    uint64_t _tmp83_val;
    uint64_t imm_val;
    uint64_t _tmp84_val;
    pc_val = hart.get_pc();
    uint64_t _val = 4U;
    _tmp83_val = pc_val + _val;
    rd_val = _tmp83_val;
    imm_val = static_cast<uint64_t>(instr.imm);
    _tmp84_val = pc_val + imm_val;
    hart.set_next_pc(_tmp84_val);
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::JAL);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


void execute_ecall(const DecodedInstruction instr, Hart& hart) {
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ECALL);
    auto __ph = pre_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }

  // Generated from IR
      uint64_t rd_val;
    uint64_t rs1_val;
    rs1_val = hart.get_reg(instr.rs1);
    hart.do_ecall();
    hart.set_reg(instr.rd, rd_val);
  
  {
    constexpr size_t __idx = static_cast<size_t>(InstructionOpcode::ECALL);
    auto __ph = post_handlers_vec[__idx];
    if (__ph) __ph(instr, hart);
  }
}


ExecFn execute(const DecodedInstruction instr, Hart& hart) {
  switch (instr.opcode) {
    case InstructionOpcode::LB: execute_lb(instr, hart); return &execute_lb;
                case InstructionOpcode::LH: execute_lh(instr, hart); return &execute_lh;
                case InstructionOpcode::LW: execute_lw(instr, hart); return &execute_lw;
                case InstructionOpcode::LD: execute_ld(instr, hart); return &execute_ld;
                case InstructionOpcode::LBU: execute_lbu(instr, hart); return &execute_lbu;
                case InstructionOpcode::LHU: execute_lhu(instr, hart); return &execute_lhu;
                case InstructionOpcode::LWU: execute_lwu(instr, hart); return &execute_lwu;
                case InstructionOpcode::SB: execute_sb(instr, hart); return &execute_sb;
                case InstructionOpcode::SH: execute_sh(instr, hart); return &execute_sh;
                case InstructionOpcode::SW: execute_sw(instr, hart); return &execute_sw;
                case InstructionOpcode::SD: execute_sd(instr, hart); return &execute_sd;
                case InstructionOpcode::ADDIW: execute_addiw(instr, hart); return &execute_addiw;
                case InstructionOpcode::SLLIW: execute_slliw(instr, hart); return &execute_slliw;
                case InstructionOpcode::SRLIW: execute_srliw(instr, hart); return &execute_srliw;
                case InstructionOpcode::SRAIW: execute_sraiw(instr, hart); return &execute_sraiw;
                case InstructionOpcode::ADDW: execute_addw(instr, hart); return &execute_addw;
                case InstructionOpcode::SUBW: execute_subw(instr, hart); return &execute_subw;
                case InstructionOpcode::SLLW: execute_sllw(instr, hart); return &execute_sllw;
                case InstructionOpcode::SRLW: execute_srlw(instr, hart); return &execute_srlw;
                case InstructionOpcode::SRAW: execute_sraw(instr, hart); return &execute_sraw;
                case InstructionOpcode::ADD: execute_add(instr, hart); return &execute_add;
                case InstructionOpcode::SUB: execute_sub(instr, hart); return &execute_sub;
                case InstructionOpcode::SLL: execute_sll(instr, hart); return &execute_sll;
                case InstructionOpcode::SLT: execute_slt(instr, hart); return &execute_slt;
                case InstructionOpcode::SLTU: execute_sltu(instr, hart); return &execute_sltu;
                case InstructionOpcode::XOR: execute_xor(instr, hart); return &execute_xor;
                case InstructionOpcode::SRL: execute_srl(instr, hart); return &execute_srl;
                case InstructionOpcode::SRA: execute_sra(instr, hart); return &execute_sra;
                case InstructionOpcode::OR: execute_or(instr, hart); return &execute_or;
                case InstructionOpcode::AND: execute_and(instr, hart); return &execute_and;
                case InstructionOpcode::ADDI: execute_addi(instr, hart); return &execute_addi;
                case InstructionOpcode::SLTI: execute_slti(instr, hart); return &execute_slti;
                case InstructionOpcode::SLTIU: execute_sltiu(instr, hart); return &execute_sltiu;
                case InstructionOpcode::XORI: execute_xori(instr, hart); return &execute_xori;
                case InstructionOpcode::ORI: execute_ori(instr, hart); return &execute_ori;
                case InstructionOpcode::ANDI: execute_andi(instr, hart); return &execute_andi;
                case InstructionOpcode::SLLI: execute_slli(instr, hart); return &execute_slli;
                case InstructionOpcode::SRLI: execute_srli(instr, hart); return &execute_srli;
                case InstructionOpcode::SRAI: execute_srai(instr, hart); return &execute_srai;
                case InstructionOpcode::JALR: execute_jalr(instr, hart); return &execute_jalr;
                case InstructionOpcode::BEQ: execute_beq(instr, hart); return &execute_beq;
                case InstructionOpcode::BNE: execute_bne(instr, hart); return &execute_bne;
                case InstructionOpcode::BLT: execute_blt(instr, hart); return &execute_blt;
                case InstructionOpcode::BGE: execute_bge(instr, hart); return &execute_bge;
                case InstructionOpcode::BLTU: execute_bltu(instr, hart); return &execute_bltu;
                case InstructionOpcode::BGEU: execute_bgeu(instr, hart); return &execute_bgeu;
                case InstructionOpcode::LUI: execute_lui(instr, hart); return &execute_lui;
                case InstructionOpcode::AUIPC: execute_auipc(instr, hart); return &execute_auipc;
                case InstructionOpcode::JAL: execute_jal(instr, hart); return &execute_jal;
                case InstructionOpcode::ECALL: execute_ecall(instr, hart); return &execute_ecall;
    default:
      hart.handle_exception(ExceptionCause::UnknowInstruction);
      return nullptr;
  }
}

} // namespace executer
} // namespace riscv_sim

